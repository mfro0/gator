#!./avview_shell
#
#     avview preliminary version
#
#       (C) Vladimir Dergachev 2001
#       
#       GNU Public License
#       

global debug
set debug 0

source themes.scp
source alsa.scp
source v4l.scp

global control_screen

set control_screen1 ""
regexp "control=\[^ \]+" "$argv" control_screen1
regsub "control=" "$control_screen1" "" control_screen
puts "control_screen=$control_screen"

global TABLE_LIST
set TABLE_LIST [freq_get_table_list]

global file_save_path
set file_save_path "."

proc skip_args3 { a b c } {
}

global VIDEO_WINDOW

set VIDEO_WINDOW .video

global current_capture_filename
set current_capture_filename "test3.avi"

destroy .video


. configure -width 320 -height 240 
#frame .video -background #102030
eval frame .video [get_settings .video AVview]

place .video -relx 0.0 -rely 0.0 -relwidth 1.0 -relheight 1.0 -anchor nw

frame .video.onscreen_display -background [.video cget -background]
eval .video.onscreen_display configure [get_settings .video.onscreen_display AVview]
place .video.onscreen_display -relx 0.05 -rely 0.05 -anchor nw


if { $control_screen != "" } {
	toplevel .controlwin -screen "$control_screen" 
	} {
	toplevel .controlwin
	}
eval .controlwin configure [get_settings .controlwin AVview]

eval frame .controlwin.control [get_settings .controlwin.control]
eval frame .controlwin.allattributes [get_settings .controlwin.allattributes]
eval frame .controlwin.capture [get_settings .controlwin.capture]
eval frame .controlwin.alsamixer [get_settings .controlwin.alsamixer]

set c .controlwin.control

global current_port_menu
global current_encoding_menu
global current_encoding
global current_encoding_name
global current_table
set current_table -1
set current_encoding -1

eval label $c.portl -text "\"Port: \"" [get_settings $c.portl AVview]
set current_port_menu [tk_optionMenu $c.port_optionmenu current_port  none]
eval $c.port_optionmenu configure [get_settings $c.port_optionmenu AVview]
eval $current_port_menu configure [get_settings $current_port_menu AVview menu]
$current_port_menu delete 0 end
grid $c.portl $c.port_optionmenu -sticky news
grid configure $c.portl -sticky nws

eval label $c.encodingl -text "\"Encoding: \"" [get_settings $c.encodingl AVview]
set current_encoding_menu [tk_optionMenu $c.encoding_optionmenu current_encoding_name  none]
eval $c.encoding_optionmenu configure [get_settings $c.encoding_optionmenu AVview]
eval $current_encoding_menu configure [get_settings $current_encoding_menu AVview menu]
$current_encoding_menu delete 0 end
grid $c.encodingl $c.encoding_optionmenu -sticky news
grid configure $c.encodingl -sticky nws

eval label $c.tablel -text "\"Channel table: \"" [get_settings $c.tablel AVview]
set current_table_menu [tk_optionMenu $c.table_optionmenu current_table_name none]
eval $c.table_optionmenu configure [get_settings $c.table_optionmenu AVview]
eval $current_table_menu configure [get_settings $current_table_menu AVview menu]
$current_table_menu delete 0 end
foreach table $TABLE_LIST {
	$current_table_menu add radiobutton -label "$table" -value "$table" -variable current_table_name 
	}
grid $c.tablel $c.table_optionmenu -sticky news
grid configure $c.tablel -sticky nws

eval label $c.channell -text "\"Channel: \"" [get_settings $c.channell]
set current_channel_menu [tk_optionMenu $c.channel_optionmenu current_channel none]
eval $c.channel_optionmenu configure [get_settings $c.channel_optionmenu AVview]
eval $current_channel_menu configure [get_settings $current_channel_menu AVview menu]
$current_channel_menu delete 0 end
grid $c.channell $c.channel_optionmenu -sticky news
grid configure $c.channell -sticky nsw

global fullscreen_mode
set fullscreen_mode false

eval checkbutton $c.fullscreen_checkbutton -text "Fullscreen"  \
	-indicatoron false -variable fullscreen_mode [get_settings $c.fullscreen_checkbutton]
eval button $c.half_size_button -text \"Half size\" -command "make_half_size" [get_settings $c.half_size_button]

eval menubutton $c.inteface_menubutton -text "Interface" -relief raised -menu $c.inteface_menubutton.menu [get_settings $c.inteface_menubutton]
eval menu $c.inteface_menubutton.menu [get_settings $c.interface_menubutton.menu AVview]
$c.inteface_menubutton.menu add checkbutton -label "Attributes" -variable attributes_window
$c.inteface_menubutton.menu add checkbutton -label "Capture (V4L)" -variable capture_window
$c.inteface_menubutton.menu add checkbutton -label "Audio mixer (ALSA)" -variable alsa_window
$c.inteface_menubutton.menu add separator
eval menu $c.inteface_menubutton.menu.theme [get_settings $c.inteface_menubutton.menu.theme AVview]
$c.inteface_menubutton.menu add cascade -menu $c.inteface_menubutton.menu.theme -label "Theme"

grid $c.fullscreen_checkbutton $c.half_size_button $c.inteface_menubutton -padx 5 -pady 5 -sticky ns

# pack $c -expand yes -fill both
# pack .controlwin.allattributes -expand yes -fill both -pady 5 
# pack .controlwin.capture -after .controlwin.allattributes -expand yes -fill both -pady 5 -side right

grid $c - - -sticky nw
grid .controlwin.allattributes .controlwin.capture -sticky new -pady 2 
grid columnconfigure .controlwin 0 -weight 0
grid columnconfigure .controlwin 1 -weight 0
grid columnconfigure .controlwin 2 -weight 0
#grid columnconfigure .controlwin 2 -weight 1
grid rowconfigure .controlwin 2 -weight 1
#grid rowconfigure .controlwin 0 -weight 1
grid .controlwin.alsamixer -column 2 -row 1 -rowspan 2 -sticky news -pady 2 

update
update idletasks

xmisc_hidecursor .
xmisc_hidecursor .video

proc hide_cursor_timer { window } {
global hct_$window
incr hct_$window -1
if { [set hct_$window] < 1 } {
	incr hct_$window -1
	xmisc_hidecursor $window
	} {
	after 500 "hide_cursor_timer $window"
	}
}

proc set_hiding_cursor {window cursor} {
global hct_$window
set hct_$window -1
xmisc_hidecursor $window
bind $window <Motion> "global hct_$window;\
		  $window configure -cursor $cursor ; \
		  if { \[set hct_$window\] < 0 } {after 500 \"hide_cursor_timer $window\"} ;\
		 set hct_$window 4"
}

set_hiding_cursor .video left_ptr

set NUM_ADAPTORS [xv_numadaptors $VIDEO_WINDOW]
puts "NUM_ADAPTORS=$NUM_ADAPTORS"

for { set i 0 } { $i < $NUM_ADAPTORS } { incr i 1 } { 
	puts "Adaptor $i: [xv_adaptor_name $VIDEO_WINDOW $i]"
	puts "\t\ttype [xv_adaptor_type $VIDEO_WINDOW $i]"
	puts "\t\tports [xv_adaptor_ports $VIDEO_WINDOW $i]"
	if { ([lsearch -exact [xv_adaptor_type $VIDEO_WINDOW $i] input] != -1) } {
		set adaptor_name "[xv_adaptor_name $VIDEO_WINDOW $i]"
		foreach port [xv_adaptor_ports $VIDEO_WINDOW $i] {
			puts "$port $adaptor_name"
			$current_port_menu add radiobutton -label "$adaptor_name: $port" -value "$port" -variable current_port
			}
		}
	}

proc find_port_adaptor { port } {
global VIDEO_WINDOW
set NUM_ADAPTORS [xv_numadaptors $VIDEO_WINDOW]
for { set i 0 } { $i < $NUM_ADAPTORS } { incr i 1 } { 
	if { [lsearch -exact [xv_adaptor_ports $VIDEO_WINDOW $i] "$port"] >= 0 } {
		return $i
		}
	}
return -1
}

proc set_channel_table {name1 name2 op} {
global TABLE_LIST
global current_table
global current_table_name
global current_channel_menu
global current_channel
set current_table [lsearch -exact $TABLE_LIST "$current_table_name"]
if { $current_table < 0 } { return }
set CHANNEL_LIST [freq_get_channel_list $current_table]
$current_channel_menu delete 0 end
.video_menu.channel_menu delete 0 end
foreach channel $CHANNEL_LIST {	
	$current_channel_menu add radiobutton -label "$channel" -value "$channel" -variable current_channel
	.video_menu.channel_menu add radiobutton -label "$channel" -value "$channel" -variable current_channel
	}
set num_channels [llength $CHANNEL_LIST]
for {set i 16} { $i < $num_channels } {incr i 16 } {
	$current_channel_menu entryconfigure $i -columnbreak 1
	.video_menu.channel_menu entryconfigure $i -columnbreak 1
	}
}

proc set_channel {a b c} {
global current_table
global current_channel
if { $current_table < 0 } { return }
set CHANNEL_LIST [freq_get_channel_list $current_table]
global channel_freq
set channel_freq [freq_get_channel_value $current_table [lsearch -exact $CHANNEL_LIST "$current_channel" ]]
on_attribute_change XV_FREQ channel_freq a b
flash_message " Channel $current_channel "
}

proc display_video {} {

global VIDEO_WINDOW
global current_port
global current_encoding

if { $current_port == "none" } { return }
if { $current_encoding < 0 } { return }
if { ([lsearch -exact [xv_adaptor_type $VIDEO_WINDOW [find_port_adaptor $current_port] ] video] == -1) } { 
	flash_message "This port is not TV-in capable"
	return 
	}

set port_size [xv_port_encoding_size $VIDEO_WINDOW $current_port $current_encoding]

xv_setportattribute $VIDEO_WINDOW $current_port "XV_COLORKEY" [xv_getwindowbackgroundpixel $VIDEO_WINDOW]

xv_putvideo $VIDEO_WINDOW $current_port 0 0 [expr [lindex $port_size 0]-1] [expr [lindex $port_size 1]-1]
}

proc find_attribute_widget {video_window port attribute} {
set type1  [xv_port_attribute_type $video_window $port $attribute]
set range [xv_port_attribute_range $video_window $port $attribute]
set name [xv_port_attribute_name $video_window $port $attribute]
if {$name == "XV_ENCODING" } { return "none" }
if {$name == "XV_AUTOPAINT_COLORKEY" } { return "none" }
if {$name == "XV_SET_DEFAULTS" } { return "button" }
if {$name == "XV_COLORKEY" } { return "none" }
if { [lsearch $type1 "gettable"] < 0 } { return "unreadable" }
if { [lsearch $type1 "settable"] < 0 } { return "label" }
if { "$range" == "0 1" } { return "toggle" }
if { [lindex $range 1] > 1000000 } { return "entry" }
if { [lindex $range 1] < [lindex $range 0] } { return "entry" }
return "slider"
}

proc translate_attribute_name { name } {
if { $name == "XV_SET_DEFAULTS" } { return "Set defaults" }
if { $name == "XV_AUTOPAINT_COLORKEY" } { return "Autopaint colorkey" }
if { $name == "XV_DEC_BRIGHTNESS" } { return "Capture brightness"}
if { $name == "XV_DEC_CONTRAST" } { return "Capture contrast"}
if { $name == "XV_DEC_SATURATION" } { return "Capture saturation"}
if { $name == "XV_DEC_HUE" } { return "Capture hue"}
regsub "XV_" "$name" "" name1
regsub "_" "$name1" " " name1
set name2 [string tolower $name1 1 end]
set name3 [string toupper $name2 0 0]
return $name3
}

proc find_attribute_variable {video_window port attribute} {
return "ATTRIBUTE.$port.$attribute"
}

proc on_attribute_change { attr_name variable a b } {
global $variable
global VIDEO_WINDOW
global current_port
if { $current_port == "none" } { return }
xv_setportattribute $VIDEO_WINDOW $current_port $attr_name [set $variable]
#puts "$attr_name=[set $variable]"
#
# The following is a hack.. 
# do this properly after XvNotify support is complete
#
update_attribute_variables
}

proc create_attribute_widget {widget video_window port attribute} {
set range [xv_port_attribute_range $video_window $port $attribute]
set name [xv_port_attribute_name $video_window $port $attribute]
set attr_var [find_attribute_variable $video_window $port $attribute]
set type [find_attribute_widget $video_window $port $attribute]
set suffix "${port}_$attribute"
global $attr_var

global attr_count

puts "$name $range $type"
switch  $type {
	"none" {
		return
		}
	"entry" {     
		label $widget.label$suffix -text [translate_attribute_name $name]
		entry $widget.entry$suffix -textvariable $attr_var
		eval $widget.label$suffix configure [get_settings $widget.label$suffix AVview XVideo $port $attribute $attr_count]
		eval $widget.entry$suffix configure [get_settings $widget.entry$suffix AVview XVideo $port $attribute $attr_count]
		grid $widget.label$suffix $widget.entry$suffix -sticky news
		grid configure $widget.label$suffix -sticky news 
		}	
	"toggle" {
		label $widget.label$suffix -text [translate_attribute_name $name]
		checkbutton $widget.checkbutton$suffix -variable $attr_var \
			-onvalue 1 -offvalue 0
		eval $widget.label$suffix configure [get_settings $widget.label$suffix AVview XVideo $port $attribute $attr_count]
		eval $widget.checkbutton$suffix configure [get_settings $widget.checkbutton$suffix AVview XVideo $port $attribute $attr_count]
		grid $widget.label$suffix $widget.checkbutton$suffix -sticky news
		grid configure $widget.label$suffix -sticky news
		}
	"button" {
		label $widget.label$suffix -text [translate_attribute_name $name]
		button $widget.button$suffix -command "xv_setportattribute $video_window $port $name 1; update_attribute_variables"\
			-text "perform now"
		eval $widget.label$suffix configure [get_settings $widget.label$suffix AVview XVideo $port $attribute $attr_count]
		eval $widget.button$suffix configure [get_settings $widget.button$suffix AVview XVideo $port $attribute $attr_count]
		grid $widget.label$suffix $widget.button$suffix -sticky news 
		grid configure $widget.label$suffix -sticky news
		}
	"slider" {
		label $widget.label$suffix -text [translate_attribute_name $name]
		scale $widget.scale$suffix -from [lindex $range 0] -to [lindex $range 1] \
			-variable $attr_var -orient horizontal
		eval $widget.label$suffix configure [get_settings $widget.label$suffix AVview XVideo $port $attribute $attr_count]
		eval $widget.scale$suffix configure [get_settings $widget.scale$suffix AVview XVideo $port $attribute $attr_count]
		grid $widget.label$suffix $widget.scale$suffix -sticky news
		grid configure $widget.label$suffix -sticky news
		}
	}
incr attr_count
if { $type != "button" } {
	trace vdelete $attr_var w "on_attribute_change $name"
	set $attr_var [xv_getportattribute $video_window $port "$name"]
	trace variable $attr_var w "on_attribute_change $name"
	}
}

proc update_attribute_variables {} {
global VIDEO_WINDOW
global current_port
if { $current_port == "none" } { return }
set num_attributes [xv_num_port_attributes $VIDEO_WINDOW $current_port]
for {set i 0 } { $i < $num_attributes} { incr i } {
	set range [xv_port_attribute_range $VIDEO_WINDOW $current_port $i]
	set name [xv_port_attribute_name $VIDEO_WINDOW $current_port $i]
	set attr_var [find_attribute_variable $VIDEO_WINDOW $current_port $i]
	set type [find_attribute_widget $VIDEO_WINDOW $current_port $i]
	global $attr_var
	if { ($type != "button") && ($type != "none") } {
		catch "
			set $attr_var
			trace vdelete $attr_var w \"on_attribute_change $name\"
			set $attr_var [xv_getportattribute $VIDEO_WINDOW $current_port $name]
			trace variable $attr_var w \"on_attribute_change $name\"
			"
		}
	}
}

proc generate_attributes_window { af } {
global VIDEO_WINDOW
global current_port
global attributes_window

foreach win [grid slaves $af] { destroy $win }

if { $current_port == "none" } { return }
if { !$attributes_window } { 
	canvas $af.l -width 0 -height 0 -background red
	grid columnconfigure .controlwin 0 -weight 0
	grid $af.l
	return 
	}

grid columnconfigure .controlwin 0 -weight 1

label $af.title -text "Attributes" -background black -foreground white
grid $af.title - -sticky news -pady 2 -padx 2

set NUM_ATTRIBUTES [xv_num_port_attributes $VIDEO_WINDOW $current_port]
global attr_count
set attr_count 0
for { set i 0 } {$i < $NUM_ATTRIBUTES } { incr i } {
	create_attribute_widget $af $VIDEO_WINDOW $current_port $i
	}
grid columnconfigure $af 1 -weight 1
}

proc set_port {name1 name2 op} {
global current_port_menu
global current_port
global VIDEO_WINDOW
global current_encoding_menu
global current_encoding
global attributes_window

#
# check that the port is valid
#

if { [find_port_adaptor $current_port] < 0 } { 
	set current_port "none"
	return 	
	}

set NUM_ENCODINGS [xv_num_port_encodings $VIDEO_WINDOW $current_port]

$current_encoding_menu delete 0 end
for {set i 0 } {$i < $NUM_ENCODINGS} {incr i} {
	$current_encoding_menu add radiobutton -label "[xv_port_encoding_name $VIDEO_WINDOW $current_port $i]" -value "[xv_port_encoding_name $VIDEO_WINDOW $current_port $i]" -variable current_encoding_name
	}

set current_encoding [xv_getportattribute $VIDEO_WINDOW $current_port "XV_ENCODING"]
if { $current_encoding >= 0 } {
	set current_encoding_name [lindex [xv_port_encodings $VIDEO_WINDOW $current_port] $current_encoding]
	}

generate_attributes_window .controlwin.allattributes

display_video
}

proc set_encoding {name1 name2 op} {
global current_encoding_name 
global current_encoding
global current_port
global VIDEO_WINDOW

if { $current_port == "none" } { return }

set ENCODINGS [xv_port_encodings $VIDEO_WINDOW $current_port]
set current_encoding [lsearch $ENCODINGS $current_encoding_name]
if { $current_encoding > 0 } {
	on_attribute_change XV_ENCODING current_encoding a b
	}
}

proc save_settings {} {
global current_port
global current_table_name
global current_encoding_name
global current_channel
global attributes_window
global capture_window
global alsa_window
global current_alsa_device
global file_save_path
catch {
	set fileid [open "~/.avview_state" w]
	}
puts $fileid "global current_port"
puts $fileid "global current_encoding_name"
puts $fileid "global current_table_name"
puts $fileid "global current_channel"
puts $fileid "global attributes_window"
puts $fileid "global capture_window"
puts $fileid "global alsa_window"
puts $fileid "global current_alsa_device1"
if { $current_port != "none" } {
	puts $fileid "set current_port \"$current_port\""
	if { $current_encoding_name != "none" } {
		puts $fileid "set current_encoding_name \"$current_encoding_name\""
		}
	}
if { $current_table_name != "none" } {
	puts $fileid "set current_table_name \"$current_table_name\""
	if { $current_channel != "none" } {
		puts $fileid "set current_channel \"$current_channel\""
		}
	}
puts $fileid "set attributes_window $attributes_window"
puts $fileid "set capture_window $capture_window"
puts $fileid "set alsa_window $alsa_window"
puts $fileid "set current_alsa_device1 \"$current_alsa_device\""

save_theme $fileid
puts $fileid ""
save_v4l_capture $fileid

puts $fileid "global file_save_path"
puts $fileid "set file_save_path \"$file_save_path\""

close $fileid
}

proc read_settings {} {
#
# Read user-specific customizations
#
if { [file exists "~/.avview"] } {
	catch {
		set fileid [open "~/.avview" r]
		if { [catch "[read $fileid]" err_msg] } {
			puts "Error loading user customizations from ~/.avview: $err_msg"
			}
		close $fileid
		} 
	}
#
# Read settings saved automatically during exit
#
if { [file exists "~/.avview_state"] } {
	catch {
		set fileid [open "~/.avview_state" r]
		if { [catch "[read $fileid]" err_msg] } {
			puts "Error loading settings from ~/.avview_state: $err_msg"
			}
		close $fileid
		} err_msg
	}
}

proc set_fullscreen {name1 name2 op} {
global VIDEO_WINDOW
global fullscreen_mode
global saved_screensaver_mode
global saved_main_window_geometry
global saved_vw_width
global saved_vw_height

if { $fullscreen_mode } {
	#
	# Save current settings
	#
	set saved_main_window_geometry [wm geometry .]
	set saved_screensaver_mode [xmisc_getscreensaver $VIDEO_WINDOW]
	set saved_vw_width [$VIDEO_WINDOW cget -width]
	set saved_vw_height [$VIDEO_WINDOW cget -height]
	
	wm geometry . =[winfo screenwidth $VIDEO_WINDOW]x[winfo screenheight $VIDEO_WINDOW]+0+0
	

	place $VIDEO_WINDOW.onscreen_display -relx 0.05 -rely 0.05 -anchor nw
	
	wm withdraw .
	wm overrideredirect . true
	wm deiconify .
	xmisc_setfullscreen .

	$VIDEO_WINDOW configure -width [winfo screenwidth $VIDEO_WINDOW] \
		-height [winfo screenheight $VIDEO_WINDOW]
	. configure -width [winfo screenwidth $VIDEO_WINDOW] \
		-height [winfo screenheight $VIDEO_WINDOW]
	xmisc_setscreensaver $VIDEO_WINDOW 0 0 DontPreferBlanking AllowExposures \
		0 0 0 0 off
#	after idle "raise ."
	} {
	wm geometry . =$saved_main_window_geometry
	$VIDEO_WINDOW configure -width $saved_vw_width -height $saved_vw_height
	place $VIDEO_WINDOW.onscreen_display -relx 0.05 -rely 0.05 -anchor nw
	xmisc_setscreensaver $VIDEO_WINDOW [lindex $saved_screensaver_mode 0]\
					   [lindex $saved_screensaver_mode 1]\
					   [lindex $saved_screensaver_mode 2]\
					   [lindex $saved_screensaver_mode 3]\
					   [lindex $saved_screensaver_mode 4]\
					   [lindex $saved_screensaver_mode 5]\
					   [lindex $saved_screensaver_mode 6]\
					   [lindex $saved_screensaver_mode 7]\
					   [lindex $saved_screensaver_mode 8]\
					   [lindex $saved_screensaver_mode 9]
					   
	wm overrideredirect . false
	wm withdraw .
	wm deiconify .
	}
}

proc make_half_size {} {
global VIDEO_WINDOW
global fullscreen_mode

if {$fullscreen_mode} {
	set fullscreen_mode 0
	return
	}

$VIDEO_WINDOW configure -width [expr [$VIDEO_WINDOW cget -width]/2] \
			-height [expr [$VIDEO_WINDOW cget -height]/2]
wm geometry . =[$VIDEO_WINDOW cget -width]x[$VIDEO_WINDOW cget -height]
}

global flash_counter
set flash_counter -1

proc fm_countdown {} {
global flash_counter
global VIDEO_WINDOW
incr flash_counter -1
if { $flash_counter<1} {
	destroy $VIDEO_WINDOW.onscreen_display.message 
	$VIDEO_WINDOW.onscreen_display configure -width 0 -height 0
	display_video
	incr flash_counter -1
	} {
	after 1000 fm_countdown
	}
}

proc adjust_message_font {} {
global VIDEO_WINDOW
set x_size  [expr [$VIDEO_WINDOW cget -width]/20]
set y_size [expr [$VIDEO_WINDOW cget -height]/8]

if { $x_size > $y_size } {
	set f_size $y_size
	} {
	set f_size $x_size
	}
font create message_font -size -$f_size -family Helvetica -slant roman -weight normal
font delete message_font
}

proc flash_message { message } {
global VIDEO_WINDOW
set bg [$VIDEO_WINDOW cget -background]
set f_size 0
set message_font_id [font create message_font -size -$f_size -family Helvetica -slant roman -weight bold]

set m $VIDEO_WINDOW.onscreen_display.message
destroy $m
frame $m -background $bg
grid $m
label $m.l -text "$message" -font message_font -background black -foreground "#FFAA88"
grid $m.l

font delete message_font

global flash_counter
if { $flash_counter < 0 } { after 1000 fm_countdown }
set flash_counter 14
adjust_message_font
}

menu .video_menu -type normal -tearoff false
menu .video_menu.channel_menu -type normal -tearoff false
.video_menu add cascade -menu .video_menu.channel_menu -label Channel
.video_menu add checkbutton -variable fullscreen_mode -label "Fullscreen"
.video_menu add separator
.video_menu add command -label "Settings" -command "raise .controlwin"
.video_menu add separator
.video_menu add command -label "Dismiss this menu"

bind $VIDEO_WINDOW  <ButtonPress-3>  {
	global $VIDEO_WINDOW
	.video_menu post [winfo pointerx $VIDEO_WINDOW] [winfo pointery $VIDEO_WINDOW]
	}


global current_port
trace variable current_port w set_port
global current_encoding_name
trace variable current_encoding_name w set_encoding
global current_table_name
trace variable current_table_name w set_channel_table
global current_channel
trace variable current_channel w "set_channel"
global fullscreen_mode
trace variable fullscreen_mode w set_fullscreen
global attributes_window
trace variable attributes_window w  { generate_attributes_window .controlwin.allattributes ; skip_args3 }
global capture_window
trace variable capture_window w  { generate_capture_window .controlwin.capture ; skip_args3 }
global current_v4l_device
trace variable current_v4l_device w  "set_v4l_device .controlwin.capture"
global current_v4l_mode
set current_v4l_mode "single-frame"
trace variable current_v4l_mode w {update_v4l_window_info .controlwin.capture ; skip_args3 }
global v4l_capture_on
set v4l_capture_on false
trace variable v4l_capture_on w "on_v4l_capture_set .controlwin.capture"
global current_video_codec
set current_video_codec "MPEG-4"
global current_audio_codec
set current_audio_codec "PCM"
global current_av_format
set current_av_format "AVI"
global current_v4l_rrate
set current_v4l_rrate "as is"
global current_v4l_device
set current_v4l_device "none"
global alsa_window
trace variable alsa_window w "generate_alsa_window .controlwin.alsamixer ; skip_args3"
trace variable current_alsa_device1 w "set_alsa_device .controlwin.alsamixer ; skip_args3"

bind $VIDEO_WINDOW <Configure> {
	global $VIDEO_WINDOW
	display_video
	place $VIDEO_WINDOW.onscreen_display -relx 0.05 -rely 0.05 -anchor nw
	adjust_message_font
	}


read_settings

wm protocol . WM_DELETE_WINDOW { save_settings ; exit }
wm protocol .controlwin WM_DELETE_WINDOW { save_settings ; exit }
wm title . "AV Viewer"
wm title .controlwin "AV Control"

#
# Generate theme menu
#
$c.inteface_menubutton.menu.theme delete 0 end
foreach theme [lsort -ascii [array names theme_list]] {
	$c.inteface_menubutton.menu.theme add radiobutton -label "$theme" \
		-value "$theme" -variable theme_name \
		-command {global theme_name ; reset_theme $theme_name}
	}
