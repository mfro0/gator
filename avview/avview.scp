#!./avview
#
#     avview preliminary version
#
#       (C) Vladimir Dergachev 2001
#       
#       GNU Public License
#       
global control_screen

set control_screen1 ""
regexp "control=\[^ \]+" "$argv" control_screen1
regsub "control=" "$control_screen1" "" control_screen
puts "control_screen=$control_screen"

global TABLE_LIST
set TABLE_LIST [freq_get_table_list]

proc skip_args3 { a b c } {
}

global VIDEO_WINDOW

set VIDEO_WINDOW .video

destroy .video

. configure -width 320 -height 240
frame .video -background #102030

place .video -relx 0.0 -rely 0.0 -relwidth 1.0 -relheight 1.0 -anchor nw
# .video configure -cursor no

frame .video.onscreen_display -background [.video cget -background]
place .video.onscreen_display -relx 0.05 -rely 0.05 -anchor nw


if { $control_screen != "" } {
	toplevel .controlwin -screen "$control_screen" 
	} {
	toplevel .controlwin
	}

frame .controlwin.control
frame .controlwin.allattributes
frame .controlwin.capture

set c .controlwin.control

global current_port_menu
global current_encoding_menu
global current_encoding
global current_encoding_name
global current_table
set current_table -1
set current_encoding -1

label $c.portl -text "Port: "
set current_port_menu [tk_optionMenu $c.portom current_port  none]
$current_port_menu delete 0 end
grid $c.portl $c.portom -sticky news
grid configure $c.portl -sticky nws

label $c.encodingl -text "Encoding: "
set current_encoding_menu [tk_optionMenu $c.encodingom current_encoding_name  none]
$current_encoding_menu delete 0 end
grid $c.encodingl $c.encodingom -sticky news
grid configure $c.encodingl -sticky nws

label $c.tablel -text "Channel table: "
set current_table_menu [tk_optionMenu $c.tableom current_table_name none]
$current_table_menu delete 0 end
foreach table $TABLE_LIST {
	$current_table_menu add radiobutton -label "$table" -value "$table" -variable current_table_name
	}
grid $c.tablel $c.tableom -sticky news
grid configure $c.tablel -sticky nws

label $c.channell -text "Channel: "
set current_channel_menu [tk_optionMenu $c.channelom current_channel none]
$current_channel_menu delete 0 end
grid $c.channell $c.channelom -sticky news
grid configure $c.channell -sticky nsw

global fullscreen_mode
set fullscreen_mode false

checkbutton $c.fullscreen -text "Fullscreen"  \
	-indicatoron false -variable fullscreen_mode
button $c.half_size -text "Half size" -command "make_half_size"

menubutton $c.interface -text "Interface" -relief raised -menu $c.interface.menu
menu $c.interface.menu 
$c.interface.menu add checkbutton -label "Attributes" -variable attributes_window
$c.interface.menu add checkbutton -label "Capture (V4L)" -variable capture_window

grid $c.fullscreen $c.half_size $c.interface -padx 5 -pady 5 -sticky ns

# pack $c -expand yes -fill both
# pack .controlwin.allattributes -expand yes -fill both -pady 5 
# pack .controlwin.capture -after .controlwin.allattributes -expand yes -fill both -pady 5 -side right

grid $c - -sticky nw
grid .controlwin.allattributes .controlwin.capture  -sticky new
grid columnconfigure .controlwin 0 -weight 0
grid columnconfigure .controlwin 1 -weight 0
#grid columnconfigure .controlwin 2 -weight 1
grid rowconfigure .controlwin 2 -weight 1

update

xmisc_hidecursor .
xmisc_hidecursor .video

proc hide_cursor_timer { window } {
global hct_$window
incr hct_$window -1
if { [set hct_$window] < 1 } {
	incr hct_$window -1
	xmisc_hidecursor $window
	} {
	after 500 "hide_cursor_timer $window"
	}
}

proc set_hiding_cursor {window cursor} {
global hct_$window
set hct_$window -1
xmisc_hidecursor $window
bind $window <Motion> "global hct_$window;\
		  $window configure -cursor $cursor ; \
		  if { \[set hct_$window\] < 0 } {after 500 \"hide_cursor_timer $window\"} ;\
		 set hct_$window 4"
}

set_hiding_cursor .video left_ptr

set NUM_ADAPTORS [xv_numadaptors $VIDEO_WINDOW]
puts "NUM_ADAPTORS=$NUM_ADAPTORS"

for { set i 0 } { $i < $NUM_ADAPTORS } { incr i 1 } { 
	puts "Adaptor $i: [xv_adaptor_name $VIDEO_WINDOW $i]"
	puts "\t\ttype [xv_adaptor_type $VIDEO_WINDOW $i]"
	puts "\t\tports [xv_adaptor_ports $VIDEO_WINDOW $i]"
	if { ([lsearch -exact [xv_adaptor_type $VIDEO_WINDOW $i] input] != -1) } {
		set adaptor_name "[xv_adaptor_name $VIDEO_WINDOW $i]"
		foreach port [xv_adaptor_ports $VIDEO_WINDOW $i] {
			puts "$port $adaptor_name"
			$current_port_menu add radiobutton -label "$adaptor_name: $port" -value "$port" -variable current_port
			}
		}
	}

proc find_port_adaptor { port } {
global VIDEO_WINDOW
set NUM_ADAPTORS [xv_numadaptors $VIDEO_WINDOW]
for { set i 0 } { $i < $NUM_ADAPTORS } { incr i 1 } { 
	if { [lsearch -exact [xv_adaptor_ports $VIDEO_WINDOW $i] "$port"] >= 0 } {
		return $i
		}
	}
return -1
}

proc set_channel_table {name1 name2 op} {
global TABLE_LIST
global current_table
global current_table_name
global current_channel_menu
global current_channel
set current_table [lsearch -exact $TABLE_LIST "$current_table_name"]
if { $current_table < 0 } { return }
set CHANNEL_LIST [freq_get_channel_list $current_table]
$current_channel_menu delete 0 end
foreach channel $CHANNEL_LIST {	
	$current_channel_menu add radiobutton -label "$channel" -value "$channel" -variable current_channel
	}
set num_channels [llength $CHANNEL_LIST]
for {set i 16} { $i < $num_channels } {incr i 16 } {
	$current_channel_menu entryconfigure $i -columnbreak 1
	}
}

proc set_channel {a b c} {
global current_table
global current_channel
if { $current_table < 0 } { return }
set CHANNEL_LIST [freq_get_channel_list $current_table]
global channel_freq
set channel_freq [freq_get_channel_value $current_table [lsearch -exact $CHANNEL_LIST "$current_channel" ]]
on_attribute_change XV_FREQ channel_freq a b
flash_message " Channel $current_channel "
}

proc display_video {} {

global VIDEO_WINDOW
global current_port
global current_encoding

if { $current_port == "none" } { return }
if { $current_encoding < 0 } { return }
if { ([lsearch -exact [xv_adaptor_type $VIDEO_WINDOW [find_port_adaptor $current_port] ] video] == -1) } { 
	flash_message "This port is not TV-in capable"
	return 
	}

set port_size [xv_port_encoding_size $VIDEO_WINDOW $current_port $current_encoding]

xv_setportattribute $VIDEO_WINDOW $current_port "XV_COLORKEY" [xv_getwindowbackgroundpixel $VIDEO_WINDOW]

xv_putvideo $VIDEO_WINDOW $current_port 0 0 [lindex $port_size 0] [lindex $port_size 1]
}

proc find_attribute_widget {video_window port attribute} {
set type1  [xv_port_attribute_type $video_window $port $attribute]
set range [xv_port_attribute_range $video_window $port $attribute]
set name [xv_port_attribute_name $video_window $port $attribute]
if {$name == "XV_ENCODING" } { return "none" }
if {$name == "XV_AUTOPAINT_COLORKEY" } { return "none" }
if {$name == "XV_SET_DEFAULTS" } { return "button" }
if {$name == "XV_COLORKEY" } { return "none" }
if { [lsearch $type1 "gettable"] < 0 } { return "unreadable" }
if { [lsearch $type1 "settable"] < 0 } { return "label" }
if { "$range" == "0 1" } { return "toggle" }
if { [lindex $range 1] > 1000000 } { return "entry" }
if { [lindex $range 1] < [lindex $range 0] } { return "entry" }
return "slider"
}

proc translate_attribute_name { name } {
if { $name == "XV_SET_DEFAULTS" } { return "Set defaults" }
if { $name == "XV_AUTOPAINT_COLORKEY" } { return "Autopaint colorkey" }
regsub "XV_" "$name" "" name1
regsub "_" "$name1" " " name1
set name2 [string tolower $name1 1 end]
set name3 [string toupper $name2 0 0]
return $name3
}

proc find_attribute_variable {video_window port attribute} {
return "ATTRIBUTE.$port.$attribute"
}

proc on_attribute_change { attr_name variable a b } {
global $variable
global VIDEO_WINDOW
global current_port
if { $current_port == "none" } { return }
xv_setportattribute $VIDEO_WINDOW $current_port $attr_name [set $variable]
#puts "$attr_name=[set $variable]"
#
# The following is a hack.. 
# do this properly after XvNotify support is complete
#
update_attribute_variables
}

proc create_attribute_widget {widget video_window port attribute} {
set range [xv_port_attribute_range $video_window $port $attribute]
set name [xv_port_attribute_name $video_window $port $attribute]
set attr_var [find_attribute_variable $video_window $port $attribute]
set type [find_attribute_widget $video_window $port $attribute]
set suffix "${port}_$attribute"
global $attr_var

puts "$name $range $type"
switch  $type {
	"none" {
		return
		}
	"entry" {     
		label $widget.l$suffix -text [translate_attribute_name $name]
		entry $widget.x$suffix -textvariable $attr_var
		grid $widget.l$suffix $widget.x$suffix -sticky news -padx 2
		grid configure $widget.l$suffix -sticky nw 
		}	
	"toggle" {
		label $widget.l$suffix -text [translate_attribute_name $name]
		checkbutton $widget.x$suffix -variable $attr_var \
			-onvalue 1 -offvalue 0
		grid $widget.l$suffix $widget.x$suffix -sticky news -padx 2
		grid configure $widget.l$suffix -sticky nw
		}
	"button" {
		label $widget.l$suffix -text [translate_attribute_name $name]
		button $widget.x$suffix -command "xv_setportattribute $video_window $port $name 1"\
			-text "perform now"
		grid $widget.l$suffix $widget.x$suffix -sticky news -padx 2
		grid configure $widget.l$suffix -sticky nw
		}
	"slider" {
		label $widget.l$suffix -text [translate_attribute_name $name]
		scale $widget.x$suffix -from [lindex $range 0] -to [lindex $range 1] \
			-variable $attr_var -orient horizontal
		grid $widget.l$suffix $widget.x$suffix -sticky news -padx 2
		grid configure $widget.l$suffix -sticky sw
		}
	}
if { $type != "button" } {
	trace vdelete $attr_var w "on_attribute_change $name"
	set $attr_var [xv_getportattribute $video_window $port "$name"]
	trace variable $attr_var w "on_attribute_change $name"
	}
}

proc update_attribute_variables {} {
global VIDEO_WINDOW
global current_port
if { $current_port == "none" } { return }
set num_attributes [xv_num_port_attributes $VIDEO_WINDOW $current_port]
for {set i 0 } { $i < $num_attributes} { incr i } {
	set range [xv_port_attribute_range $VIDEO_WINDOW $current_port $i]
	set name [xv_port_attribute_name $VIDEO_WINDOW $current_port $i]
	set attr_var [find_attribute_variable $VIDEO_WINDOW $current_port $i]
	set type [find_attribute_widget $VIDEO_WINDOW $current_port $i]
	global $attr_var
	if { ($type != "button") && ($type != "none") } {
		catch "
			set $attr_var
			trace vdelete $attr_var w \"on_attribute_change $name\"
			set $attr_var [xv_getportattribute $VIDEO_WINDOW $current_port $name]
			trace variable $attr_var w \"on_attribute_change $name\"
			"
		}
	}
}

proc generate_attributes_window { af } {
global VIDEO_WINDOW
global current_port
global attributes_window

foreach win [grid slaves $af] { destroy $win }

if { $current_port == "none" } { return }
if { !$attributes_window } { 
	canvas $af.l -width 0 -height 0 -background red
	grid columnconfigure .controlwin 0 -weight 0
	grid $af.l
	return 
	}

grid columnconfigure .controlwin 0 -weight 1

label $af.title -text "Attributes" -background black -foreground white
grid $af.title - -sticky news -pady 2 -padx 2

set NUM_ATTRIBUTES [xv_num_port_attributes $VIDEO_WINDOW $current_port]

for { set i 0 } {$i < $NUM_ATTRIBUTES } { incr i } {
	create_attribute_widget $af $VIDEO_WINDOW $current_port $i
	}
grid columnconfigure $af 1 -weight 1
}

proc set_port {name1 name2 op} {
global current_port_menu
global current_port
global VIDEO_WINDOW
global current_encoding_menu
global current_encoding
global attributes_window

#
# check that the port is valid
#

if { [find_port_adaptor $current_port] < 0 } { 
	set current_port "none"
	return 	
	}

set NUM_ENCODINGS [xv_num_port_encodings $VIDEO_WINDOW $current_port]

$current_encoding_menu delete 0 end
for {set i 0 } {$i < $NUM_ENCODINGS} {incr i} {
	$current_encoding_menu add radiobutton -label "[xv_port_encoding_name $VIDEO_WINDOW $current_port $i]" -value "[xv_port_encoding_name $VIDEO_WINDOW $current_port $i]" -variable current_encoding_name
	}

set current_encoding [xv_getportattribute $VIDEO_WINDOW $current_port "XV_ENCODING"]
if { $current_encoding >= 0 } {
	set current_encoding_name [lindex [xv_port_encodings $VIDEO_WINDOW $current_port] $current_encoding]
	}

generate_attributes_window .controlwin.allattributes

display_video
}

proc set_encoding {name1 name2 op} {
global current_encoding_name 
global current_encoding
global current_port
global VIDEO_WINDOW

if { $current_port == "none" } { return }

set ENCODINGS [xv_port_encodings $VIDEO_WINDOW $current_port]
set current_encoding [lsearch $ENCODINGS $current_encoding_name]
if { $current_encoding > 0 } {
	on_attribute_change XV_ENCODING current_encoding a b
	}
}

proc save_settings {} {
global current_port
global current_table_name
global current_encoding_name
global current_channel
global attributes_window
global capture_window
global current_codec
catch {
	set fileid [open "~/.avview_state" w]
	}
puts $fileid "global current_port"
puts $fileid "global current_encoding_name"
puts $fileid "global current_table_name"
puts $fileid "global current_channel"
puts $fileid "global current_codec"
puts $fileid "global attributes_window"
puts $fileid "global capture_window"
puts $fileid "set current_codec $current_codec"
if { $current_port != "none" } {
	puts $fileid "set current_port \"$current_port\""
	if { $current_encoding_name != "none" } {
		puts $fileid "set current_encoding_name \"$current_encoding_name\""
		}
	}
if { $current_table_name != "none" } {
	puts $fileid "set current_table_name \"$current_table_name\""
	if { $current_channel != "none" } {
		puts $fileid "set current_channel \"$current_channel\""
		}
	}
puts $fileid "set attributes_window $attributes_window"
puts $fileid "set capture_window $capture_window"
close $fileid
}

proc read_settings {} {
#
# Read settings saved automatically during exit
#
if { [file exists "~/.avview_state"] } {
	catch {
		set fileid [open "~/.avview_state" r]
		catch "[read $fileid]"
		close $fileid
		}
	}
#
# Read user-specific customizations
#
if { [file exists "~/.avview"] } {
	catch {
		set fileid [open "~/.avview" r]
		catch "[read $fileid]"
		close $fileid
		}
	}
}

proc set_fullscreen {name1 name2 op} {
global VIDEO_WINDOW
global fullscreen_mode
global saved_screensaver_mode
global saved_main_window_geometry
global saved_vw_width
global saved_vw_height

if { $fullscreen_mode } {
	#
	# Save current settings
	#
	set saved_main_window_geometry [wm geometry .]
	set saved_screensaver_mode [xmisc_getscreensaver $VIDEO_WINDOW]
	set saved_vw_width [$VIDEO_WINDOW cget -width]
	set saved_vw_height [$VIDEO_WINDOW cget -height]
	
	wm geometry . =[winfo screenwidth $VIDEO_WINDOW]x[winfo screenheight $VIDEO_WINDOW]+0+0
	$VIDEO_WINDOW configure -width [winfo screenwidth $VIDEO_WINDOW] \
		-height [winfo screenheight $VIDEO_WINDOW]

	place $VIDEO_WINDOW.onscreen_display -relx 0.05 -rely 0.05 -anchor nw
	xmisc_setscreensaver $VIDEO_WINDOW 0 0 DontPreferBlanking AllowExposures \
		0 0 0 0 off
	} {
	wm geometry . =$saved_main_window_geometry
	$VIDEO_WINDOW configure -width $saved_vw_width -height $saved_vw_height
	place $VIDEO_WINDOW.onscreen_display -relx 0.05 -rely 0.05 -anchor nw
	xmisc_setscreensaver $VIDEO_WINDOW [lindex $saved_screensaver_mode 0]\
					   [lindex $saved_screensaver_mode 1]\
					   [lindex $saved_screensaver_mode 2]\
					   [lindex $saved_screensaver_mode 3]\
					   [lindex $saved_screensaver_mode 4]\
					   [lindex $saved_screensaver_mode 5]\
					   [lindex $saved_screensaver_mode 6]\
					   [lindex $saved_screensaver_mode 7]\
					   [lindex $saved_screensaver_mode 8]\
					   [lindex $saved_screensaver_mode 9]
					   
	}
}

proc make_half_size {} {
global VIDEO_WINDOW
global fullscreen_mode

if {$fullscreen_mode} {
	set fullscreen_mode 0
	return
	}

$VIDEO_WINDOW configure -width [expr [$VIDEO_WINDOW cget -width]/2] \
			-height [expr [$VIDEO_WINDOW cget -height]/2]
wm geometry . =[$VIDEO_WINDOW cget -width]x[$VIDEO_WINDOW cget -height]
}

global flash_counter
set flash_counter -1

proc fm_countdown {} {
global flash_counter
global VIDEO_WINDOW
incr flash_counter -1
if { $flash_counter<1} {
	destroy $VIDEO_WINDOW.onscreen_display.message 
	$VIDEO_WINDOW.onscreen_display configure -width 0 -height 0
	display_video
	incr flash_counter -1
	} {
	after 1000 fm_countdown
	}
}

proc adjust_message_font {} {
global VIDEO_WINDOW
set x_size  [expr [$VIDEO_WINDOW cget -width]/20]
set y_size [expr [$VIDEO_WINDOW cget -height]/8]

if { $x_size > $y_size } {
	set f_size $y_size
	} {
	set f_size $x_size
	}
font create message_font -size -$f_size -family Helvetica -slant roman -weight normal
font delete message_font
}

proc flash_message { message } {
global VIDEO_WINDOW
set bg [$VIDEO_WINDOW cget -background]
set f_size 0
set message_font_id [font create message_font -size -$f_size -family Helvetica -slant roman -weight normal]

set m $VIDEO_WINDOW.onscreen_display.message
destroy $m
frame $m -background $bg
grid $m
label $m.l -text "$message" -font message_font -background black -foreground "#FFAA88"
grid $m.l

font delete message_font

global flash_counter
if { $flash_counter < 0 } { after 1000 fm_countdown }
set flash_counter 14
adjust_message_font
}

proc generate_capture_window { cw } {
global capture_window
foreach win [grid slaves $cw] { destroy $win }

if { !$capture_window } { 
	grid columnconfigure .controlwin 1 -weight 0
	canvas $cw.f -width 0 -height 0 -background red
	grid $cw.f
	return 
	}
grid columnconfigure .controlwin 1 -weight 1

label $cw.title -text "Capture (V4L)" -background black -foreground white
grid $cw.title - - -sticky news -pady 2 -padx 2
grid columnconfigure $cw 1 -weight 1
label $cw.devicel -text "V4L device: "
global v4l_device_menu
set v4l_device_menu [tk_optionMenu $cw.deviceom current_v4l_device none]
button $cw.rescanb -text "Rescan" -command rescan_v4l_devices
grid $cw.devicel $cw.deviceom $cw.rescanb -sticky news
grid configure $cw.devicel -sticky nws

label $cw.model -text "Recording mode: "
tk_optionMenu $cw.modeom current_v4l_mode single-frame deinterlace-bob deinterlace-weave half-width
grid $cw.model $cw.modeom - -sticky news
grid configure $cw.model -sticky nws

label $cw.windowl -text "Window: "
label $cw.window -text "N/A"
button $cw.windowb -text "Change"
grid $cw.windowl $cw.window $cw.windowb
grid configure $cw.windowl -sticky nws
grid configure $cw.windowb -sticky news

if {[ffmpeg_present] == "yes"} {
	label $cw.rratel -text "Recording framerate: "
	tk_optionMenu $cw.rrateom current_v4l_rrate "as is" "one half" "one quarter"
	grid $cw.rratel $cw.rrateom - -sticky news
	grid configure $cw.rratel -sticky nws

	label $cw.codecl -text "Recording format:"
	tk_optionMenu $cw.codecom current_codec "H263" "H263I" "H263P" "MJPEG" "MPEG-1" "MPEG-4" "MSMPEG-4" "RV10"
	grid $cw.codecl $cw.codecom
	grid configure $cw.codecl -sticky nws
	grid configure $cw.codecom -sticky news
	button $cw.snapshotb -text "Snapshot" -command capture_snapshot -state disabled
	checkbutton $cw.recordb -text "Record" -variable v4l_capture_on \
		-indicatoron false -state disabled
	grid x $cw.snapshotb $cw.recordb -sticky ns -padx 5
	label $cw.fifol -text "Fifo size: "
	label $cw.fifov -text "0 Mb"
	grid $cw.fifol $cw.fifov -sticky nws
	} {
	button $cw.snapshotb -text "Snapshot" -command capture_snapshot -state disabled
	grid x $cw.snapshotb
	}
rescan_v4l_devices
}

proc rescan_v4l_devices {} {
global v4l_device_menu
global current_v4l_device
set current_v4l_device none
$v4l_device_menu delete 0 end
$v4l_device_menu add radiobutton -label "none"\
				-value "none" -variable current_v4l_device
for {set i 0 } {$i < 10 } { incr i } {
	set status "[v4l_open_device rescan_handle /dev/video$i]"
	if { "$status" == "" } {
		set type [v4l_device_type rescan_handle]
		if { [lsearch $type capture] >= 0 } {
			$v4l_device_menu add radiobutton -label "/dev/video$i: [v4l_device_name rescan_handle]"\
				-value "/dev/video$i" -variable current_v4l_device
			}
		v4l_close_device rescan_handle
		}
	}
}

proc update_v4l_window_info {cw} {
global current_v4l_device
global current_v4l_mode
if { "$current_v4l_device" == "none" } { 
	$cw.window configure -text "N/A"
	return 
	}
set window [v4l_get_current_window current_v4l_handle]
switch "$current_v4l_mode" \
	"single-frame" {
		$cw.window configure -text "[lindex $window 2]x[lindex $window 3]+[lindex $window 0]+[lindex $window 1]"
		} \
	"deinterlace-bob" {
		$cw.window configure -text "[lindex $window 2]x[expr [lindex $window 3]*2]+[lindex $window 0]+[expr [lindex $window 1]*2]"
		}\
	"deinterlace-weave" {
		$cw.window configure -text "[lindex $window 2]x[expr [lindex $window 3]*2]+[lindex $window 0]+[expr [lindex $window 1]*2]"
		}\
	"half-width" {
		$cw.window configure -text "[expr [lindex $window 2]/2]x[lindex $window 3]+[lindex $window 0]+[expr [lindex $window 1]*2]"
		}

}

proc set_v4l_device {cw name1 name2 op } {
global current_v4l_device
global v4l_capture_on
if { "$current_v4l_device" == "none" } { 
	v4l_close_device current_v4l_handle
	set v4l_capture_on false
	catch {
		$cw.recordb configure -state disabled
		$cw.snapshotb configure -state disabled
		}
	return 
	}
set status "[v4l_open_device current_v4l_handle $current_v4l_device]"
if { "$status" != "" } {
	set current_v4l_device "none"
	}
$cw.recordb configure -state normal
$cw.snapshotb configure -state normal
update_v4l_window_info $cw
}

global snp_window_count
set snp_window_count 0

proc capture_snapshot {} {
global current_v4l_device
global snp_window_count
global current_v4l_mode
if { "$current_v4l_device" == "none" } { 
	return
	}
incr snp_window_count
image create photo .snapshot$snp_window_count.image
v4l_capture_snapshot current_v4l_handle .snapshot$snp_window_count.image $current_v4l_mode {
	global snp_window_count
	create_snapshot_window .snapshot$snp_window_count.image
	} {
	global snp_window_count
	puts "Error capturing image $snp_window_count" 
	}
}

proc create_snapshot_window {image} {
global control_screen
global snp_window_count
set sw .snapshot$snp_window_count
if { "$control_screen" != "" } {
	toplevel $sw -screen "$control_screen"
	} {
	toplevel $sw
	}
wm title $sw "Snapshot $snp_window_count"
frame $sw.f
grid $sw.f - -sticky news
canvas $sw.c -xscrollcommand "$sw.hscroll set" \
	-yscrollcommand "$sw.vscroll set" -relief sunken -bd 2
scrollbar $sw.vscroll -command "$sw.c yview"
scrollbar $sw.hscroll -command "$sw.c xview" -orient horiz
grid $sw.c $sw.vscroll 
grid $sw.hscroll x
grid configure $sw.c -sticky news
grid configure $sw.vscroll -sticky ns
grid configure $sw.hscroll -sticky ew
grid rowconfig $sw 1 -weight 1
grid columnconfig $sw 0 -weight 1
$sw.c create image 0 0 -anchor nw -image $image
# size the canvas
set screenheight [expr [winfo screenheight $sw.c] - 40]
set screenwidth [expr [winfo screenwidth $sw.c] - 20]
set width [image width $image]
set height [image height $image]

# scrollregion
$sw.c configure -scrollregion "-10 -10 $width $height"

# size - truncate to fit screen
if { $width > $screenwidth } { set width $screenwidth }
if { $height > $screenheight } { set height $screenheight}

$sw.c configure -width $width -height $height

#
# Now populate control frame
#

button $sw.f.sab -text "Save as" -command "save_image_as $sw $image"

tk_optionMenu $sw.f.type save_type Postscript PPM

grid $sw.f.sab $sw.f.type -padx 5
update
}

proc save_image_as { sw image } {
global save_type
puts "$image $save_type"
switch "$save_type" \
	"Postscript" {
		set file [tk_getSaveFile -defaultextension .eps \
			-filetypes {{"Postscript" {.eps .ps}} {"All files" {.*}}} -parent $sw]
		if { "$file" != "" } {
			$sw.c postscript -file "$file"
			}
		} \
	"PPM" {
		set file [tk_getSaveFile -defaultextension .ppm \
			-filetypes {{"PPM" {.ppm}} {"All files" {.*}}} -parent $sw]
		if { "$file" != "" } {
			$image write "$file" -format ppm
			}
		}
}

proc on_v4l_capture_set {cw name1 name2 w } {
global v4l_capture_on
global current_codec
global current_v4l_mode
global current_v4l_rrate
if { $v4l_capture_on } {
	set status [ffmpeg_encode_v4l_stream current_v4l_handle $current_codec $current_v4l_mode $current_v4l_rrate "hello.mpg"]
	if { "$status" == "" } { 
		after cancel "check_fifo $cw"
		after 800 "check_fifo $cw"
		}
	puts "status=$status"
	} {
	ffmpeg_stop_encoding current_v4l_handle
	}
}

proc check_fifo { cw } {
catch {
	set size [ffmpeg_incoming_fifo_size current_v4l_handle]
	$cw.fifov configure -text "[expr $size/(1024*1024)] Mb"
	}
after 800 "check_fifo $cw"
}

global current_port
trace variable current_port w set_port
global current_encoding_name
trace variable current_encoding_name w set_encoding
global current_table_name
trace variable current_table_name w set_channel_table
global current_channel
trace variable current_channel w "set_channel"
global fullscreen_mode
trace variable fullscreen_mode w set_fullscreen
global attributes_window
trace variable attributes_window w  { generate_attributes_window .controlwin.allattributes ; skip_args3 }
global capture_window
trace variable capture_window w  { generate_capture_window .controlwin.capture ; skip_args3 }
global current_v4l_device
trace variable current_v4l_device w  "set_v4l_device .controlwin.capture"
global current_v4l_mode
set current_v4l_mode single-frame
trace variable current_v4l_mode w {update_v4l_window_info .controlwin.capture ; skip_args3 }
global v4l_capture_on
set v4l_capture_on false
trace variable v4l_capture_on w "on_v4l_capture_set .controlwin.capture"
global current_codec
set current_codec "MPEG-4"

bind $VIDEO_WINDOW <Configure> {
	global $VIDEO_WINDOW
	display_video
	place $VIDEO_WINDOW.onscreen_display -relx 0.05 -rely 0.05 -anchor nw
	adjust_message_font
	}


read_settings

wm protocol . WM_DELETE_WINDOW { save_settings ; exit }
wm protocol .controlwin WM_DELETE_WINDOW { save_settings ; exit }
wm title . "AV Viewer"
wm title .controlwin "AV Control"

