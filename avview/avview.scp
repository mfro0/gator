#!./avview_shell
#
# The line above is only for testing.. You should really start avview
# with start_avview
#
#
#     avview preliminary version
#
#       (C) Vladimir Dergachev 2001-2002
#       
#       GNU Public License
#       

global control_screen
set control_screen1 ""
regexp "control=\[^ \]+" "$argv" control_screen1
regsub "control=" "$control_screen1" "" control_screen
puts "control_screen=$control_screen"

foreach {variable value} {
	debug 0
	show_control_window 0
	file_save_path "."
	current_capture_filename "test3.avi"
	fullscreen_mode false
	remember_fullscreen_state false
	always_start_fullscreen false
	display_setup_window_on_startup false
	current_v4l_mode "single-frame"
	v4l_capture_on false
	current_video_codec "MPEG-1"
	current_audio_codec "MPEG-2"
	current_v4l_rrate "as is"
	current_v4l_device "none"
	current_av_format "MPEG"
	current_port "none"
	current_encoding "none"
	current_encoding_name "none"
	current_table "none"
	current_table_name "none"
	current_channel "none"
	use_physical_screen_size true
	aspect_ratio {4 3}
	} {
	global $variable
	set $variable $value
	}


global TABLE_LIST
set TABLE_LIST [freq_get_table_list]

foreach file {xmisc.scp tree.scp setup.scp themes.scp alsa.scp
	v4l.scp xv.scp channel_scan.scp ffmpeg.scp 
	video_device.scp diag.scp bindings.scp} {
	source $avview_directory/$file
	}



proc skip_args3 { a b c } {
}

global VIDEO_WINDOW

set VIDEO_WINDOW .video

destroy .video


. configure -width 320 -height 240 -background black

#frame .video -background #102030
eval frame .video [get_settings .video AVview]
.video configure -borderwidth 0
place .video -relx 0.0 -rely 0.0 -relwidth 1.0 -relheight 1.0 -anchor nw

bind . <Configure> place_video_window

proc place_video_window {} {
global aspect_ratio use_physical_screen_size
set h [winfo height .]
set w [winfo width .]
set rw 1.0
set rh 1.0
#catch {
	if { $use_physical_screen_size } {
		set a_x [expr ([lindex $aspect_ratio 0]*[winfo screenwidth .]*1.0)/[winfo screenmmwidth .]]
		set a_y [expr ([lindex $aspect_ratio 1]*[winfo screenheight .]*1.0)/[winfo screenmmheight .]]
		} {
		set a_x [lindex $aspect_ratio 0]
		set a_y [lindex $aspect_ratio 1]
		}
	if { $a_x*$h>=$a_y*$w } {
		set rh [expr (1.0*$a_y*$w)/($a_x*$h)]
		set rw 1.0
		} {
		set rw [expr (1.0*$a_x*$h)/($a_y*$w)]
		set rh 1.0
		}
#	}
place configure .video -relx [expr (1.0-$rw)/2.0] -rely [expr (1.0-$rh)/2.0] \
	-relw $rw -relh $rh -anchor nw
}

frame .video.onscreen_display -background [.video cget -background]
eval .video.onscreen_display configure [get_settings .video.onscreen_display AVview]
place .video.onscreen_display -relx 0.05 -rely 0.05 -anchor nw


if { $control_screen != "" } {
	toplevel .controlwin -screen "$control_screen" 
	} {
	toplevel .controlwin
	}
wm withdraw .controlwin
eval .controlwin configure [get_settings .controlwin AVview]

eval frame .controlwin.control [get_settings .controlwin.control]
eval frame .controlwin.allattributes [get_settings .controlwin.allattributes]
eval frame .controlwin.capture [get_settings .controlwin.capture]
eval frame .controlwin.alsamixer [get_settings .controlwin.alsamixer]

set c .controlwin.control

global current_port_menu
global current_encoding_menu

#eval label $c.portl -text "\"Port: \"" [get_settings $c.portl AVview]
#set current_port_menu [tk_optionMenu $c.port_optionmenu current_port  none]
#eval $c.port_optionmenu configure [get_settings $c.port_optionmenu AVview]
#eval $current_port_menu configure [get_settings $current_port_menu AVview menu]
#$current_port_menu delete 0 end
#grid $c.portl $c.port_optionmenu -sticky news
#grid configure $c.portl -sticky nws

eval label $c.encodingl -text "\"Encoding: \"" [get_settings $c.encodingl AVview]
set current_encoding_menu [tk_optionMenu $c.encoding_optionmenu current_encoding_name  none]
eval $c.encoding_optionmenu configure [get_settings $c.encoding_optionmenu AVview]
eval $current_encoding_menu configure [get_settings $current_encoding_menu AVview menu]
$current_encoding_menu delete 0 end
grid $c.encodingl $c.encoding_optionmenu -sticky news
grid configure $c.encodingl -sticky nws

#eval label $c.tablel -text "\"Channel table: \"" [get_settings $c.tablel AVview]
#set current_table_menu [tk_optionMenu $c.table_optionmenu current_table_name none]
#eval $c.table_optionmenu configure [get_settings $c.table_optionmenu AVview]
#eval $current_table_menu configure [get_settings $current_table_menu AVview menu]
#$current_table_menu delete 0 end
#foreach table $TABLE_LIST {
#	$current_table_menu add radiobutton -label "$table" -value "$table" -variable current_table_name 
#	}
#grid $c.tablel $c.table_optionmenu -sticky news
#grid configure $c.tablel -sticky nws

eval label $c.channell -text "\"Channel: \"" [get_settings $c.channell]
set current_channel_menu [tk_optionMenu $c.channel_optionmenu current_channel none]
eval $c.channel_optionmenu configure [get_settings $c.channel_optionmenu AVview]
eval $current_channel_menu configure [get_settings $current_channel_menu AVview menu]
$current_channel_menu delete 0 end
grid $c.channell $c.channel_optionmenu -sticky news
grid configure $c.channell -sticky nsw


#eval checkbutton $c.fullscreen_checkbutton -text "Fullscreen"  \
#	-indicatoron false -variable fullscreen_mode [get_settings $c.fullscreen_checkbutton]
#eval button $c.half_size_button -text \"Half size\" -command "make_half_size" [get_settings $c.half_size_button]

#eval menubutton $c.interface_menubutton -text "Interface" -relief raised -menu $c.interface_menubutton.menu [get_settings $c.interface_menubutton]
#eval menu $c.interface_menubutton.menu [get_settings $c.interface_menubutton.menu AVview]
#$c.interface_menubutton.menu add checkbutton -label "Show main control window" -variable show_control_window
#$c.interface_menubutton.menu add checkbutton -label "Attributes" -variable attributes_window
#$c.interface_menubutton.menu add checkbutton -label "Capture (V4L)" -variable capture_window
#if { [alsa_present] == "yes" } {
#	$c.interface_menubutton.menu add checkbutton -label "Audio mixer (ALSA)" -variable alsa_window
#	} 
#$c.interface_menubutton.menu add separator
#$c.interface_menubutton.menu add command -label "Favorite channel editor" -command scan_channels
#eval menu $c.interface_menubutton.menu.theme [get_settings $c.interface_menubutton.menu.theme AVview]
#$c.interface_menubutton.menu add cascade -menu $c.interface_menubutton.menu.theme -label "Theme"
#$c.interface_menubutton.menu add separator
#$c.interface_menubutton.menu add command -label "Exit" -command {
#	ffmpeg_stop_encoding
#	save_settings
#	exit
#	}

#grid $c.fullscreen_checkbutton $c.half_size_button $c.interface_menubutton -padx 5 -pady 5 -sticky ns

# pack $c -expand yes -fill both
# pack .controlwin.allattributes -expand yes -fill both -pady 5 
# pack .controlwin.capture -after .controlwin.allattributes -expand yes -fill both -pady 5 -side right

grid $c - - -sticky nw
grid .controlwin.allattributes -column 0 -row 1 -rowspan 2 -sticky news -pady 2 
grid .controlwin.capture -column 1 -row 1 -rowspan 1 -sticky new -pady 2 
grid columnconfigure .controlwin 0 -weight 0
grid columnconfigure .controlwin 1 -weight 0
grid columnconfigure .controlwin 2 -weight 0
#grid columnconfigure .controlwin 2 -weight 1
grid rowconfigure .controlwin 2 -weight 1
#grid rowconfigure .controlwin 0 -weight 1
grid .controlwin.alsamixer -column 2 -row 1 -rowspan 2 -sticky news -pady 2 

update
update idletasks

xmisc_hidecursor .
xmisc_hidecursor .video

trace variable show_control_window w "show_control_window_proc ; skip_args3"

proc show_control_window_proc {} {
global show_control_window
if { $show_control_window } {
	after idle { wm deiconify .controlwin }
	} {
	after idle {
		global show_control_window
		if { "[winfo screen .controlwin]" != "[winfo screen . ]" } {
			set ans [tk_dialog .controlwin.withdraw_question "Hide main control window ?" \
				"The main control window is displayed on the monitor different from main viewer window. If you hide it you will only be able to restore it from the main viewer window. Perhaps you would prefer to iconify control window?" "" 0 "Iconify" "Hide" "Never mind" ]
			update
			update idletasks
			switch "$ans" \
				"0"  { after idle {wm iconify .controlwin ; set show_control_window 1 } } \
				"1"  { after idle { wm withdraw .controlwin } } \
				"2"  { set show_control_window 1 }
			update
			} {
			after idle { wm withdraw .controlwin }
			}
		}
	}
} 

proc hide_cursor_timer { window } {
global hct_$window
incr hct_$window -1
if { [set hct_$window] < 1 } {
	incr hct_$window -1
	xmisc_hidecursor $window
	} {
	after 500 "hide_cursor_timer $window"
	}
}

proc set_hiding_cursor {window cursor} {
global hct_$window
set hct_$window -1
xmisc_hidecursor $window
bind $window <Motion> "global hct_$window;\
		  $window configure -cursor $cursor ; \
		  if { \[set hct_$window\] < 0 } {after 500 \"hide_cursor_timer $window\"} ;\
		 set hct_$window 4"
}

set_hiding_cursor .video left_ptr

#set NUM_ADAPTORS [xv_numadaptors $VIDEO_WINDOW]
#puts "NUM_ADAPTORS=$NUM_ADAPTORS"

#for { set i 0 } { $i < $NUM_ADAPTORS } { incr i 1 } { 
#	puts "Adaptor $i: [xv_adaptor_name $VIDEO_WINDOW $i]"
#	puts "\t\ttype [xv_adaptor_type $VIDEO_WINDOW $i]"
#	puts "\t\tports [xv_adaptor_ports $VIDEO_WINDOW $i]"
#	if { ([lsearch -exact [xv_adaptor_type $VIDEO_WINDOW $i] input] != -1) } {
#		set adaptor_name "[xv_adaptor_name $VIDEO_WINDOW $i]"
#		foreach port [xv_adaptor_ports $VIDEO_WINDOW $i] {
#			puts "$port $adaptor_name"
#			$current_port_menu add radiobutton -label "$adaptor_name: $port" -value "$port" -variable current_port
#			}
#		}
#	}

proc find_port_adaptor { port } {
global VIDEO_WINDOW
set NUM_ADAPTORS [xv_numadaptors $VIDEO_WINDOW]
for { set i 0 } { $i < $NUM_ADAPTORS } { incr i 1 } { 
	if { [lsearch -exact [xv_adaptor_ports $VIDEO_WINDOW $i] "$port"] >= 0 } {
		return $i
		}
	}
return -1
}

proc set_channel_table {name1 name2 op} {
global TABLE_LIST
global current_table
global current_table_name
global current_channel_menu
global current_channel
set current_table [lsearch -exact $TABLE_LIST "$current_table_name"]
if { $current_table < 0 } { return }
set CHANNEL_LIST [freq_get_channel_list $current_table]
$current_channel_menu delete 0 end
.video_menu.channel_menu delete 0 end
foreach channel $CHANNEL_LIST {	
	$current_channel_menu add radiobutton -label "$channel" -value "$channel" -variable current_channel
	.video_menu.channel_menu add radiobutton -label "$channel" -value "$channel" -variable current_channel
	}
set num_channels [llength $CHANNEL_LIST]
for {set i 16} { $i < $num_channels } {incr i 16 } {
	$current_channel_menu entryconfigure $i -columnbreak 1
	.video_menu.channel_menu entryconfigure $i -columnbreak 1
	}
reflect_favorite_channels
}

proc set_channel {a b c} {
global current_table
global current_channel
if { $current_table < 0 } { return }
set CHANNEL_LIST [freq_get_channel_list $current_table]
global channel_freq
set channel_freq [freq_get_channel_value $current_table [lsearch -exact $CHANNEL_LIST "$current_channel" ]]
flash_message " Channel $current_channel "
update
on_attribute_change XV_FREQ channel_freq a b
}

proc display_video {} {

global VIDEO_WINDOW
global current_port
global current_encoding

if { $current_port == "none" } { return }
if { $current_encoding < 0 } { return }
if { ([lsearch -exact [xv_adaptor_type $VIDEO_WINDOW [find_port_adaptor $current_port] ] video] == -1) } { 
	flash_message "This port is not TV-in capable"
	return 
	}

set port_size [xv_port_encoding_size $VIDEO_WINDOW $current_port $current_encoding]

xv_setportattribute $VIDEO_WINDOW $current_port "XV_COLORKEY" [xv_getwindowbackgroundpixel $VIDEO_WINDOW]

xv_putvideo $VIDEO_WINDOW $current_port 0 0 [expr [lindex $port_size 0]-1] [expr [lindex $port_size 1]-1]
}


proc set_encoding {name1 name2 op} {
global current_encoding_name current_encoding current_port current_video_rate
global current_table_name current_table VIDEO_WINDOW


if { $current_port == "none" } { return }

set ENCODINGS [xv_port_encodings $VIDEO_WINDOW $current_port]
set current_encoding [lsearch $ENCODINGS $current_encoding_name]
if { $current_encoding > 0 } {
	on_attribute_change XV_ENCODING current_encoding a b
	switch -glob -- "$current_encoding_name" \
		"*pal*" {
			set current_video_rate 50.00
			} \
		"*secam*" {
			set current_video_rate 50.00
			} \
		"*ntsc*" {
			set current_video_rate 59.94
			}			
			
	}
}

proc save_settings {} {
if { [catch {
	set fileid [open "~/.avview_state" w]
	} ] != 0 } { return }

global avview_version
puts $fileid "\n# AVview version this file was saved with\n"
puts $fileid "set saved_avview_version \"$avview_version\""

puts $fileid "\n# General settings"

foreach variable {current_port current_encoding_name current_table_name
	current_channel attributes_window capture_window alsa_window
	 show_control_window always_start_fullscreen remember_fullscreen_state
	display_setup_window_on_startup file_save_path} {
	global $variable
	puts $fileid "\nglobal $variable"
	puts $fileid "set $variable \"[set $variable]\""
	}
global aspect_ratio
puts $fileid "\nglobal aspect_ratio"
puts $fileid "set aspect_ration \[list $aspect_ratio\]"
save_theme $fileid
puts $fileid "update idletasks"

global current_alsa_device
puts $fileid "\nglobal current_alsa_device1"
puts $fileid "set current_alsa_device1 \"$current_alsa_device\""
puts $fileid ""
save_v4l_capture $fileid
puts $fileid ""
save_favorite_channels $fileid

global fullscreen_mode
if { $remember_fullscreen_state && $fullscreen_mode } {
	puts $fileid "\n# Restore fullscreen mode"
	puts $fileid "global fullscreen_mode"
	puts $fileid "set fullscreen_mode true"
	}
close $fileid
}

proc read_settings {} {
#
# Read user-specific customizations
#
set saved_avview_version ""
if { [file exists "~/.avview"] } {
	catch {
		set fileid [open "~/.avview" r]
		if { [catch "[read $fileid]" err_msg] } {
			puts "Error loading user customizations from ~/.avview: $err_msg"
			}
		close $fileid
		} 
	}
#
# Read settings saved automatically during exit
#
if { [file exists "~/.avview_state"] } {
	catch {
		set fileid [open "~/.avview_state" r]
		if { [catch "[read $fileid]" err_msg] } {
			puts "Error loading settings from ~/.avview_state: $err_msg"
			}
		close $fileid
		} err_msg
	}
global avview_version
if { $avview_version != $saved_avview_version } {
	wm deiconify .setup
	update
	update idletasks
	raise .setup
	update
	update idletasks
	tk_messageBox -parent .setup -icon info\
		-type ok -message "It appears you have not run AVview $avview_version before.\nPlease verify that all settings are correct."
	}
}

proc check_mapped_state {} {
puts "4. state=[wm state .] mapped=[winfo ismapped .]"
after 300 check_mapped_state
}

# For debugging
#check_mapped_state

global in_set_fullscreen
set in_set_fullscreen false

proc set_fullscreen {} {
global VIDEO_WINDOW
global fullscreen_mode
global saved_screensaver_mode
global saved_main_window_geometry
global saved_vw_width
global saved_vw_height
global in_set_fullscreen

if { $in_set_fullscreen } { return }
set in_set_fullscreen true

if { $fullscreen_mode } {
	#
	# Save current settings
	#
	set saved_main_window_geometry [wm geometry .]
	set saved_screensaver_mode [xmisc_getscreensaver $VIDEO_WINDOW]
	set saved_vw_width [$VIDEO_WINDOW cget -width]
	set saved_vw_height [$VIDEO_WINDOW cget -height]

	xmisc_setscreensaver $VIDEO_WINDOW 0 0 DontPreferBlanking AllowExposures \
		0 0 0 0 off
	
	wm withdraw .
	wm overrideredirect . true
	update
#	after idle {
		while { [wm state .] != "normal" } {
			wm state . normal
			after 100
			update
			update idletasks
			}
		set screen_width   [winfo screenwidth $VIDEO_WINDOW]
		set screen_height  [winfo screenheight $VIDEO_WINDOW]

		wm geometry . =${screen_width}x${screen_height}+0+0
		place $VIDEO_WINDOW.onscreen_display -relx 0.05 -rely 0.05 -anchor nw
		
		update
		update idletasks
#		xmisc_setfullscreen .
		wm geometry . =${screen_width}x${screen_height}+0+0

	#	. configure -width $screen_width \
	#		-height $screen_height  -background red
		$VIDEO_WINDOW configure -width ${screen_width} \
			-height ${screen_height}
		display_video
		update
#		puts "1. state=[wm state .]"
		while { [wm state .] != "normal" } {
#			puts "2. state=[wm state .]"
			after 100
			wm state . normal
			update
			update idletasks
			}
#		puts "3. state=[wm state .] mapped=[winfo ismapped .]"
		$VIDEO_WINDOW configure -width ${screen_width} \
			-height ${screen_height}
		wm geometry . =${screen_width}x${screen_height}+0+0
		grab -global .
		focus -force .
#		}
	} {
	$VIDEO_WINDOW configure -width $saved_vw_width -height $saved_vw_height
	place $VIDEO_WINDOW.onscreen_display -relx 0.05 -rely 0.05 -anchor nw
	xmisc_setscreensaver $VIDEO_WINDOW [lindex $saved_screensaver_mode 0]\
					   [lindex $saved_screensaver_mode 1]\
					   [lindex $saved_screensaver_mode 2]\
					   [lindex $saved_screensaver_mode 3]\
					   [lindex $saved_screensaver_mode 4]\
					   [lindex $saved_screensaver_mode 5]\
					   [lindex $saved_screensaver_mode 6]\
					   [lindex $saved_screensaver_mode 7]\
					   [lindex $saved_screensaver_mode 8]\
					   [lindex $saved_screensaver_mode 9]
					   
	wm overrideredirect . false
	wm withdraw .
	wm geometry . =$saved_main_window_geometry
	update 
	update idletasks
	wm deiconify .
	update 
	update idletasks
	wm geometry . =$saved_main_window_geometry
	grab release .
	focus -force .
	}
set in_set_fullscreen false
}

proc make_half_size {} {
global VIDEO_WINDOW
global fullscreen_mode

if {$fullscreen_mode} {
	set fullscreen_mode 0
	return
	}

$VIDEO_WINDOW configure -width [expr [winfo width $VIDEO_WINDOW]/2] \
			-height [expr [winfo height $VIDEO_WINDOW]/2]
wm geometry . =[$VIDEO_WINDOW cget -width]x[$VIDEO_WINDOW cget -height]
}

proc make_double_size {} {
global VIDEO_WINDOW
global fullscreen_mode

if {$fullscreen_mode} {
	set fullscreen_mode 0
	return
	}

$VIDEO_WINDOW configure -width [expr [winfo width $VIDEO_WINDOW]*2] \
			-height [expr [winfo height $VIDEO_WINDOW]*2]
wm geometry . =[$VIDEO_WINDOW cget -width]x[$VIDEO_WINDOW cget -height]
}

proc make_aspect_ratio {xr yr} {
global VIDEO_WINDOW
global fullscreen_mode

if {$fullscreen_mode} {
	set fullscreen_mode 0
	return
	}
set current_width [winfo width $VIDEO_WINDOW]
set current_height [winfo width $VIDEO_WINDOW]
set new_width [expr $current_height*$xr/$yr]
set new_height [expr $current_width*$yr/$xr]

if { $new_width <= $current_width } { 
	set new_height $current_height 
	} {
	set new_width $current_width
	}

$VIDEO_WINDOW configure -width $new_width -height $new_height
wm geometry . =[$VIDEO_WINDOW cget -width]x[$VIDEO_WINDOW cget -height]
}

global flash_counter
set flash_counter -1

proc fm_countdown {} {
global flash_counter
global VIDEO_WINDOW
incr flash_counter -1
if { $flash_counter<1} {
	destroy $VIDEO_WINDOW.onscreen_display.message 
	$VIDEO_WINDOW.onscreen_display configure -width 0 -height 0
	display_video
	incr flash_counter -1
	} {
	after 1000 fm_countdown
	}
}

proc adjust_message_font {} {
global VIDEO_WINDOW
set x_size  [expr [winfo width $VIDEO_WINDOW]/20]
set y_size [expr [winfo height $VIDEO_WINDOW]/8]

if { $x_size > $y_size } {
	set f_size $y_size
	} {
	set f_size $x_size
	}
catch {
	font delete message_font
	}
font create message_font -size -$f_size -family Helvetica -slant roman -weight normal
}

proc flash_message { message } {
global VIDEO_WINDOW
set bg [$VIDEO_WINDOW cget -background]
set f_size 0
#font delete message_font
adjust_message_font
#set message_font_id [font create message_font -size -$f_size -family Helvetica -slant roman -weight bold]

set m $VIDEO_WINDOW.onscreen_display.message
destroy $m
frame $m -background $bg
raise $m
grid $m
label $m.l -text "$message" -font message_font -background black -foreground "#FFAA88"
grid $m.l


global flash_counter
if { $flash_counter < 0 } { after 1000 fm_countdown }
set flash_counter 14
}

menu .video_menu -type normal -tearoff false
menu .video_menu.size_menu -type normal -tearoff false
menu .video_menu.channel_menu -type normal -tearoff false
menu .video_menu.interface_menu -type normal -tearoff false
menu .video_menu.interface_menu.theme_menu -type normal -tearoff false

.video_menu add command -label "Toggle mute" -command { toggle_mute }
.video_menu add cascade -menu .video_menu.channel_menu -label "Channel"
.video_menu add cascade -menu .video_menu.size_menu -label "Size"
.video_menu add separator
.video_menu add cascade -menu .video_menu.interface_menu -label "User interface"
.video_menu add separator
.video_menu add command -label "Exit AVview" -command { save_settings; exit }
.video_menu add separator
.video_menu add command -label "Dismiss this menu"

.video_menu.size_menu add checkbutton -variable fullscreen_mode -label "Fullscreen" -onvalue true -offvalue false
.video_menu.size_menu add command -label "Half size" -command "make_half_size"
.video_menu.size_menu add command -label "Double size" -command "make_double_size"
.video_menu.size_menu add radiobutton -label "Unconstrained aspect ratio" -variable aspect_ratio -value [list NONE NONE]
.video_menu.size_menu add radiobutton -label "Aspect ratio 4:3" -variable aspect_ratio -value [list 4 3]
.video_menu.size_menu add radiobutton -label "Aspect ratio 3:4" -variable aspect_ratio -value [list 3 4]
.video_menu.size_menu add radiobutton -label "Aspect ratio 16:9" -variable aspect_ratio -value [list 16 9]
.video_menu.size_menu add radiobutton -label "Aspect ratio 9:16" -variable aspect_ratio -value [list 9 16]
#.video_menu.size_menu add command -label "Adjust to 4:3 aspect ratio" -command "make_aspect_ratio 4 3"
#.video_menu.size_menu add command -label "Adjust to 16:9 aspect ratio" -command "make_aspect_ratio 16 9"
#.video_menu.size_menu add command -label "Adjust to 9:16 aspect ratio" -command "make_aspect_ratio 9 16"

.video_menu.interface_menu add command -label "Show setup window" -command "create_setup_window"
.video_menu.interface_menu add command -label "Favorite channel editor" -command scan_channels
.video_menu.interface_menu add separator
.video_menu.interface_menu add checkbutton -label "Show control window" -variable show_control_window
.video_menu.interface_menu add checkbutton -label "Show Xv attributes section" -variable attributes_window
.video_menu.interface_menu add checkbutton -label "Show capture (V4L) section" -variable capture_window
if { [alsa_present] == "yes" } {
	.video_menu.interface_menu add checkbutton -label "Show audio mixer (ALSA) section" -variable alsa_window
	} 
.video_menu.interface_menu add separator
.video_menu.interface_menu add cascade -label "Theme" -menu .video_menu.interface_menu.theme_menu

bind .video_menu <Unmap> {
	grab release .video_menu
	grab -global .
	focus -force .
	}
	
bind $VIDEO_WINDOW  <ButtonPress-3>  {
	global $VIDEO_WINDOW
	#.video_menu post [winfo pointerx $VIDEO_WINDOW] [winfo pointery $VIDEO_WINDOW]
	tk_popup .video_menu [winfo pointerx $VIDEO_WINDOW] [winfo pointery $VIDEO_WINDOW]
	grab .video_menu
	}


global current_port
trace variable current_port w set_port
global current_encoding_name
trace variable current_encoding_name w set_encoding
global current_table_name
trace variable current_table_name w set_channel_table
global current_channel
trace variable current_channel w "set_channel"
global fullscreen_mode
trace variable fullscreen_mode w "set_fullscreen ; skip_args3"
global attributes_window
trace variable attributes_window w  { generate_attributes_window .controlwin.allattributes ; skip_args3 }
global capture_window
trace variable capture_window w  { generate_capture_window .controlwin.capture ; skip_args3 }
global current_v4l_device
trace variable current_v4l_device w  "set_v4l_device .controlwin.capture"
global current_v4l_mode
trace variable current_v4l_mode w {update_v4l_window_info .controlwin.capture ; skip_args3 }
global v4l_capture_on
trace variable v4l_capture_on w "on_v4l_capture_set .controlwin.capture"
trace variable aspect_ratio w "place_video_window ; skip_args3"
trace variable use_physical_screen_size w "place_video_window ; skip_args3"

if {[alsa_present] == "yes" } {
	trace variable alsa_window w "generate_alsa_window .controlwin.alsamixer ; skip_args3"
	}

bind $VIDEO_WINDOW <Configure> {
	global $VIDEO_WINDOW
	display_video
	place $VIDEO_WINDOW.onscreen_display -relx 0.05 -rely 0.05 -anchor nw
	if { [winfo exists $VIDEO_WINDOW.control] } {
		destroy $VIDEO_WINDOW.control
		next_control 0
		}
	adjust_message_font
	}



wm protocol . WM_DELETE_WINDOW { 
        if { [ffmpeg_present] == "yes" } {
                ffmpeg_stop_encoding
                }
	save_settings  
	exit 
	}
#wm protocol .controlwin WM_DELETE_WINDOW {
#        if { [ffmpeg_present] == "yes" } {
#                ffmpeg_stop_encoding
#                }
#	 save_settings
#	 exit 
#	 }

wm protocol .controlwin WM_DELETE_WINDOW {
	global show_control_window
	set show_control_window false
	}

wm title . "AVview"
wm aspect . 3 4 3 4
wm title .controlwin "AV Control"

#
# Generate theme menu
#
#$c.interface_menubutton.menu.theme delete 0 end
.video_menu.interface_menu.theme_menu delete 0 end
foreach theme [lsort -ascii [array names theme_list]] {
#	$c.interface_menubutton.menu.theme add radiobutton -label "$theme" \
#		-value "$theme" -variable theme_name \
#		-command {global theme_name ; reset_theme $theme_name}

	.video_menu.interface_menu.theme_menu add radiobutton -label "$theme" \
		-value "$theme" -variable theme_name \
		-command {global theme_name ; reset_theme $theme_name}
	}

if { [alsa_present] } {
	add_parameter_pane "/User interface settings" "User interface settings" \
		"Display setup window on startup" checkbutton display_setup_window_on_startup \
		"Display control window" checkbutton show_control_window \
		"Display attributes subsection" checkbutton attributes_window \
		"Display capture(V4L) subsection" checkbutton capture_window \
		"Display mixer(ALSA) subsection" checkbutton alsa_window \
		"Use physical screen size for aspect ratio" checkbutton use_physical_screen_size
	} {
	add_parameter_pane "/User interface settings" "User interface settings" \
		"Display setup window on startup" checkbutton display_setup_window_on_startup \
		"Display control window" checkbutton show_control_window \
		"Display attributes subsection" checkbutton attributes_window \
		"Display capture(V4L) subsection" checkbutton capture_window \
		"Use physical screen size for aspect ratio" checkbutton use_physical_screen_size
	}

add_parameter_pane "/User interface settings/Fullscreen behaviour" "Fullscreen behaviour" \
		"Remember fullscreen state for new sessions" checkbutton remember_fullscreen_state \
		"Always start fullscreen" checkbutton always_start_fullscreen

Tree:open .setup.tree "/User interface settings"

replace_parameter_choices "/Video device parameters" 0 a
regenerate_port_menu

after idle {
	avview_set_icon . "avview-16x16.ppm"
	avview_set_icon .controlwin "avview-control-16x16.ppm"
	}

after 100 {
	assign_default_bindings
	read_settings
	switch_to_pane "/User interface settings"
	if { $display_setup_window_on_startup } {
		create_setup_window
		}
	if { $always_start_fullscreen && ! $fullscreen_mode } {
		set fullscreen_mode true 
		}
	xv_pick_defaults
	}	
	
